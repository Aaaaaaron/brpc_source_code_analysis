## 为什么需要重试

客户端发送失败的原因：
1、服务器断线，发送的请求或者返回的响应（正常返回或者包含错误提示的返回）丢失（TCP连接异常，如何检测到？）
2、服务器正在重启或关机，不能服务
3、服务器接收队列过大

重试过程总结：
（在重试的基础上，增加backup_req功能）
1、第一次发送，可能由于以下因素造成未收到正常响应：
   TCP连接异常导致发送失败
   服务器正在重启或退出，不能服务  ELOGOFF  EHOSTDOWN
   服务器接收队列过大，不能响应本次请求  ELIMIT
   发送成功后，TCP连接异常，导致未收到正常响应或包含errno的响应
2、由于以上四点，客户端产生重试，进行第二次发送，第二次发送也可能遇到上述问题，就算第二次发送成功收到响应，第一次被认为失败的请求也可能收到响应（TCP异常后自动恢复），第二次的返回需要和第一次的返回做互斥
3、第一次的请求如果在backup_req_ms内未收到响应，会进行backup_req的发送（占用一次重试次数）
   backup_req也会遇到上述四点问题（会不会重试？）
4、在整体timeout时间内，只要有一次响应成功，就算rpc成功，否则认为rpc超时，不再进行重试
5、一次成功的response处理完，Id结构就被销毁，处理其他重试返回的response时的bthread_id_lock操作直接返回失败

断线（或者路由器崩溃）场景：
1、客户端发送数据时断线
2、客户端发送成功，数据在路上时断线，服务器未收到
3、客户端发送成功，服务器读取时断线
4、客户顿发送成功，服务器处理后发送响应时断线
5、客户端发送成功，服务器处理后发送响应成功，响应在路上时断线
6、一条报文，由于断线，接收时可能在inode接收缓存中只存在一部分，作为非法数据处理

断线、断电发生时内核的动作：什么都不会发生

epoll的错误触发条件：
1、对端正常关闭（程序里close()，shell下kill或ctr+c），对端TCP都会发送FIN，本端触发EPOLLIN和EPOLLRDHUP，但是不触发EPOLLERR和EPOLLHUP
   EPOLLRDHUP : 对端关闭连接或者shutdown写入半连接
   本端read返回0，然后关闭本端fd
   EPOLLERR或者EPOLLHUP应该是本端出错才触发的（？）
   
   对端异常关闭（什么是异常关闭？不是指拔掉网线），应该是本端内核的fd也失效了（？），写数据时会报错，这时才知道对端异常关闭，本端要进行错误处理
   
   拔掉网线，应该是两端都没感觉，客户端要处理已发数据的超时处理、应用层已排队数据对应协程的唤起处理以及这些协程的发送重试处理（内核让epoll通知应用层，然后read返回-1和非INTR的errno，就可以进行出错处理）
   
2、拔掉网线或者路由器崩溃，没触发任何事件
3、这样想对不对：网线断开，应用层写数据是将数据写入inode缓存，所以体会不到已断开；内核发送数据不成功（直接发送失败、长期收不到已发数据的Ack等等），由epoll返回错误，应用层做错误处理
