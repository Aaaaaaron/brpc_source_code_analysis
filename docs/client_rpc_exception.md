[RPC请求发送过程可能会遇到的异常情况](#RPC请求发送过程可能会遇到的异常情况)

[brpc对各类发送异常的处理方式](#brpc对各类发送异常的处理方式)

## RPC请求发送过程可能会遇到的异常情况
在一次RPC过程中（假设客户端fd与服务端fd原先已正常建立TCP长连接），客户端向服务器发送请求时可能会遇到如下各类异常：

1. 服务器限流

   服务器接收请求的队列的长度超出阈值，此时服务器不能再负责处理新到的请求，否则服务器可能压力过大而崩溃。

2. 服务器正在退出

   服务器正在退出服务，此时服务器进程虽然存活，但不能响应客户端的请求。

3. 服务器进程正常关闭fd

   服务器进程正常关闭fd包括三种情况：
   
   - 服务器进程主动调用close关闭fd；
   
   - 服务器进程主动调用exit；
   
   - 在shell下kill或ctrl+c杀掉服务器进程。
   
   以上三种情况都会正常关闭服务端fd，TCP连接上会将FIN发给客户端，客户端的epoll会通知客户端的fd可读，对客户端的fd执行read调用的返回值是0。

4. 机器断电导致的服务器进程异常关闭

   服务器进程所在的机器可能在如下时刻断电：
   
   - 客户端发送数据过程中服务器机器断电
   
     这里的客户端发送数据指的是客户端机器内核TCP/IP协议栈向服务器发送数据，客户端进程只是将数据写入fd的内核inode发送缓存，操作系统内核的TCP/IP协议栈负责将inode发送缓存里的数据发到
   
   - 客户端已将数据发到网络上，服务器进程接到请求数据前机器断电
   
   - 服务器进程处理请求过程中断电
   
     

5. 网络掉线，包括网线断开、客户端与服务器间的路由器故障等

   

各环节失败的处理方式
Channel::HandleSendFailed
客户端发送失败的原因：
1、服务器断线，发送的请求或者返回的响应（正常返回或者包含错误提示的返回）丢失（TCP连接异常，如何检测到？）
2、服务器正在重启或关机，不能服务
3、服务器接收队列过大
客户端errno的理解：
ERPCTIMEDOUT：RPC整体过程超时，指的是发送的请求（包括重试的请求）都没有返回，或者返回的是无效的数据，整体超时后不会再去重试
              该errno由定时器设置
EFAILEDSOCKET：TCP连接出现问题，需要重试。（TCP可以自动重连？之前出错的TCP连接上仍然可能有响应返回，需要跟重试产生的响应做互斥）
重试过程总结：
（在重试的基础上，增加backup_req功能）
1、第一次发送，可能由于以下因素造成未收到正常响应：
   TCP连接异常导致发送失败
   服务器正在重启或退出，不能服务  ELOGOFF  EHOSTDOWN
   服务器接收队列过大，不能响应本次请求  ELIMIT
   发送成功后，TCP连接异常，导致未收到正常响应或包含errno的响应
2、由于以上四点，客户端产生重试，进行第二次发送，第二次发送也可能遇到上述问题，就算第二次发送成功收到响应，第一次被认为失败的请求也可能收到响应（TCP异常后自动恢复），第二次的返回需要和第一次的返回做互斥
3、第一次的请求如果在backup_req_ms内未收到响应，会进行backup_req的发送（占用一次重试次数）
   backup_req也会遇到上述四点问题（会不会重试？）
4、在整体timeout时间内，只要有一次响应成功，就算rpc成功，否则认为rpc超时，不再进行重试
5、一次成功的response处理完，Id结构就被销毁，处理其他重试返回的response时的bthread_id_lock操作直接返回失败

具体case：
1、发送一次请求，立即返回正确响应，无重试，无backup_req，无超时
2、发送一次请求，服务器立即返回ELOGOFF或EHOSTDOWN错误，处理返回报文的协程，在OnVersionedRPCReturned里进行一次重试，_current_call要被重置为重试的请求。重试要从连接池中选择新的长连接。重试的发送逻辑应该和第一次发送请求的逻辑一样，有一样的容错机制，但不会重复设置整体超时时间和backup_req时间



完善的容错机制
断线重连：
1、发送时断线如何处理（验证：在发送数据前杀掉server进程）
2、发出去了，由于断线没收到响应如何处理（验证：发送后杀掉server进程，看客户端代码如何执行）
在频繁交互的tcp上，用心跳是无意义的

断线（或者路由器崩溃）场景：
1、客户端发送数据时断线
2、客户端发送成功，数据在路上时断线，服务器未收到
3、客户端发送成功，服务器读取时断线
4、客户顿发送成功，服务器处理后发送响应时断线
5、客户端发送成功，服务器处理后发送响应成功，响应在路上时断线
6、一条报文，由于断线，接收时可能在inode接收缓存中只存在一部分，作为非法数据处理

断线、断电发生时内核的动作：什么都不会发生

epoll的错误触发条件：
1、对端正常关闭（程序里close()，shell下kill或ctr+c），对端TCP都会发送FIN，本端触发EPOLLIN和EPOLLRDHUP，但是不触发EPOLLERR和EPOLLHUP
   EPOLLRDHUP : 对端关闭连接或者shutdown写入半连接
   本端read返回0，然后关闭本端fd
   EPOLLERR或者EPOLLHUP应该是本端出错才触发的（？）
   
   对端异常关闭（什么是异常关闭？不是指拔掉网线），应该是本端内核的fd也失效了（？），写数据时会报错，这时才知道对端异常关闭，本端要进行错误处理
   
   拔掉网线，应该是两端都没感觉，客户端要处理已发数据的超时处理、应用层已排队数据对应协程的唤起处理以及这些协程的发送重试处理（内核让epoll通知应用层，然后read返回-1和非INTR的errno，就可以进行出错处理）
   
2、拔掉网线或者路由器崩溃，没触发任何事件
3、这样想对不对：网线断开，应用层写数据是将数据写入inode缓存，所以体会不到已断开；内核发送数据不成功（直接发送失败、长期收不到已发数据的Ack等等），由epoll返回错误，应用层做错误处理

关于断线的网上资料：
1、当使用 select()函数测试一个socket是否可读时，如果select()函数返回值为1，且使用recv()函数读取的数据长度为0 时，就说明该socket已经断开。为了更好的判定socket是否断开，我判断当recv()返回值小于等于0时，socket连接断开。但是还需要判断 errno是否等于 EINTR 。如果errno == EINTR 则说明recv函数是由于程序接收到信号后返回的，socket连接还是正常的，不应close掉socket连接。


## brpc对各类发送异常的处理方式

